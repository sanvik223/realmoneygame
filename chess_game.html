
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>চেস গেম | Real Money Game</title>
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-database-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.2/firebase-auth-compat.js"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: url('https://i.postimg.cc/9f3TghpB/Wallpaper-Kemra-Black-Wood-1-jpg-optimal.jpg') no-repeat center center fixed;
            background-size: cover;
            color: #fff;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }
        
        #game-container {
            width: 100%;
            max-width: 800px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.7);
        }
        
        #reward-display {
            background: linear-gradient(135deg, #4361ee, #3f37c9);
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            font-size: 18px;
            text-align: center;
            margin-bottom: 20px;
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }
        
        #opponent-info {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            margin-bottom: 15px;
        }
        
        #player-info {
            display: flex;
            justify-content: flex-start;
            align-items: center;
            margin-top: 15px;
        }
        
        .profile {
            display: flex;
            align-items: center;
        }
        
        .profile-info {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin-right: 10px;
        }
        
        .player-profile-info {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            margin-left: 10px;
        }
        
        .profile-name {
            font-weight: bold;
            font-size: 16px;
            margin-bottom: 5px;
        }
        
        .profile-pic {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4a2e8a, #6e48aa);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
            overflow: hidden;
        }
        
        .profile-pic img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        .timer {
            background: #333;
            padding: 8px 12px;
            border-radius: 20px;
            font-family: 'Courier New', monospace;
            font-size: 16px;
            font-weight: bold;
            margin-left: 10px;
            min-width: 80px;
            text-align: center;
            color: #ffd700;
        }
        
        #board-container {
            flex: 1;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        #board {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            grid-template-rows: repeat(8, 1fr);
            width: 90vw;
            height: 90vw;
            max-width: 500px;
            max-height: 500px;
            border: 10px solid #4361ee;
            border-radius: 5px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        
        .square {
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 40px;
            cursor: pointer;
            position: relative;
        }
        
        .light {
            background-color: #f0d9b5;
        }
        
        .dark {
            background-color: #b58863;
        }
        
        .selected {
            background-color: rgba(100, 255, 100, 0.7) !important;
        }
        
        .possible-move::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(0, 0, 0, 0.3);
        }
        
        .possible-capture {
            position: relative;
        }
        
        .possible-capture::before {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            border: 3px solid rgba(255, 0, 0, 0.7);
        }
        
        .white {
            color: white;
            text-shadow: 1px 1px 2px #000;
        }
        
        .black {
            color: black;
            text-shadow: 1px 1px 2px #fff;
        }
        
        #status {
            font-size: 18px;
            font-weight: bold;
            padding: 10px;
            text-align: center;
            margin: 10px 0;
            color: #ffd700;
        }
        
        #chat-button {
            position: fixed;
            right: 20px;
            bottom: 20px;
            background: linear-gradient(135deg, #4361ee, #3f37c9);
            color: white;
            border: none;
            padding: 15px;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            z-index: 10;
        }
        
        #chat-container {
            display: none;
            position: fixed;
            right: 20px;
            bottom: 90px;
            width: 300px;
            height: 400px;
            background: #1a1a2e;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            z-index: 100;
            flex-direction: column;
            overflow: hidden;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        #chat-header {
            background: linear-gradient(135deg, #4361ee, #3f37c9);
            padding: 15px;
            font-weight: bold;
            text-align: center;
            font-size: 18px;
            color: white;
        }
        
        #chat-messages {
            flex: 1;
            padding: 10px;
            overflow-y: auto;
            background: #0f0f1a;
        }
        
        .message {
            margin-bottom: 10px;
            padding: 8px 12px;
            border-radius: 8px;
            word-wrap: break-word;
            max-width: 80%;
        }
        
        .own-message {
            background: linear-gradient(135deg, #4361ee, #3f37c9);
            margin-left: auto;
            text-align: right;
            color: white;
        }
        
        .opponent-message {
            background: #333;
            margin-right: auto;
        }
        
        #chat-input-container {
            display: flex;
            padding: 10px;
            background: #1a1a2e;
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        
        #chat-message {
            flex: 1;
            padding: 10px;
            border: none;
            border-radius: 5px 0 0 5px;
            background: #0f0f1a;
            color: #fff;
            font-size: 14px;
        }
        
        #chat-send {
            border-radius: 0 5px 5px 0;
            padding: 10px 15px;
            background: linear-gradient(135deg, #4361ee, #3f37c9);
            color: white;
            border: none;
            cursor: pointer;
        }
        
        .check {
            box-shadow: inset 0 0 20px rgba(255, 0, 0, 0.5);
        }
        
        .last-move {
            background-color: rgba(255, 255, 0, 0.3);
        }
        
        #promotion-modal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a2e;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            z-index: 100;
            border: 1px solid rgba(255,255,255,0.1);
            color: white;
        }
        
        #promotion-options {
            display: flex;
            gap: 10px;
            justify-content: center;
            margin-top: 15px;
        }
        
        .promotion-option {
            font-size: 40px;
            cursor: pointer;
            padding: 10px;
            border-radius: 5px;
            background: rgba(255,255,255,0.1);
        }
        
        .promotion-option:hover {
            background: rgba(255,255,255,0.2);
        }
        
        #back-button {
            position: fixed;
            top: 15px;
            left: 15px;
            background: rgba(0, 0, 0, 0.5);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        
        @media (max-width: 600px) {
            #board {
                width: 95vw;
                height: 95vw;
            }
            
            .square {
                font-size: 30px;
            }
            
            #chat-container {
                width: 250px;
                height: 350px;
                right: 10px;
                bottom: 80px;
            }
            
            .profile-pic {
                width: 40px;
                height: 40px;
                font-size: 16px;
            }
            
            .profile-name {
                font-size: 14px;
            }
            
            .timer {
                font-size: 14px;
                padding: 6px 10px;
                min-width: 70px;
            }
        }
    </style>
</head>
<body>
    <button id="back-button" onclick="exitGame()">
        <i class="fas fa-arrow-left"></i> বের হোন
    </button>
    
    <div id="game-container">
        <div id="game-area">
            <div id="reward-display">পুরস্কার: ৳<span id="reward-amount">0</span></div>
            
            <div id="opponent-info">
                <div class="profile">
                    <div class="profile-info">
                        <div class="profile-name" id="opponent-name">প্রতিপক্ষ</div>
                        <div class="timer" id="opponent-timer">30:00</div>
                    </div>
                    <div class="profile-pic" id="opponent-image">
                        <i class="fas fa-user"></i>
                    </div>
                </div>
            </div>
            
            <div id="board-container">
                <div id="board"></div>
            </div>
            
            <div id="player-info">
                <div class="profile">
                    <div class="profile-pic" id="player-image">
                        <i class="fas fa-user"></i>
                    </div>
                    <div class="player-profile-info">
                        <div class="profile-name" id="player-name">আপনি</div>
                        <div class="timer" id="player-timer">30:00</div>
                    </div>
                </div>
            </div>
            
            <div id="status">গেম প্রস্তুত</div>
            
            <button id="chat-button"><i class="fas fa-comment"></i></button>
            
            <div id="chat-container">
                <div id="chat-header">চ্যাট</div>
                <div id="chat-messages"></div>
                <div id="chat-input-container">
                    <input type="text" id="chat-message" placeholder="মেসেজ লিখুন...">
                    <button id="chat-send"><i class="fas fa-paper-plane"></i></button>
                </div>
            </div>
            
            <div id="promotion-modal">
                <h3>সৈনিককে রূপান্তর করুন:</h3>
                <div id="promotion-options">
                    <div class="promotion-option white" data-piece="Q">♕</div>
                    <div class="promotion-option white" data-piece="R">♖</div>
                    <div class="promotion-option white" data-piece="B">♗</div>
                    <div class="promotion-option white" data-piece="N">♘</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Firebase কনফিগারেশন
        const firebaseConfig = {
            apiKey: "AIzaSyCS5nlNZ-SA5erCj0Cf1v5KWhfnmcfPmRw",
            authDomain: "high--call-message.firebaseapp.com",
            databaseURL: "https://high--call-message-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "high--call-message",
            storageBucket: "high--call-message.appspot.com",
            messagingSenderId: "369974545305",
            appId: "1:369974545305:web:10315a079922d1931fe108",
            measurementId: "G-3E4LTER2LF"
        };

        // Firebase ইনিশিয়ালাইজ
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const auth = firebase.auth();

        // গেম ভেরিয়েবল
        let gameId;
        let playerId; // This is 1 or 2 from URL
        let playerColor; // 'white' or 'black'
        let currentPlayerTurn; // 1 or 2 (whose turn it is)
        let chessBoard = [];
        let selectedPiece = null;
        let possibleMoves = [];
        let gameRef;
        let chatRef;
        let isBoardFlipped = false;
        
        let playerTimer = 1800; 
        let opponentTimer = 1800;
        let playerTimerInterval;
        let opponentTimerInterval;
        
        let playerName = "আপনি";
        let opponentName = "প্রতিপক্ষ";
        let playerPhotoUrl = '';
        let opponentPhotoUrl = '';

        let isGameStarted = false;
        let lastMove = null;
        let checkStatus = { white: false, black: false };
        let castlingRights = {
            white: { kingSide: true, queenSide: true },
            black: { kingSide: true, queenSide: true }
        };
        let enPassantTarget = null;
        let halfMoveClock = 0;
        let fullMoveNumber = 1;
        let gameInternalStatus = 'ongoing'; // 'ongoing', 'whiteWon', 'blackWon', 'stalemate', 'draw'
        let rewardAmountDisplay = 0; // For display purposes, actual calculation by RealMoneyGame.html

        // URL থেকে গেম আইডি, প্লেয়ার আইডি এবং এন্ট্রি ফি পড়া
        const urlParams = new URLSearchParams(window.location.search);
        gameId = urlParams.get('gameId');
        playerId = parseInt(urlParams.get('playerId')); // 1 or 2
        const entryFee = parseFloat(urlParams.get('entryFee')) || 0;

        // DOM এলিমেন্ট
        const gameArea = document.getElementById('game-area');
        const statusElement = document.getElementById('status');
        const chatButton = document.getElementById('chat-button');
        const chatContainer = document.getElementById('chat-container');
        const chatMessages = document.getElementById('chat-messages');
        const chatMessageInput = document.getElementById('chat-message');
        const chatSendBtn = document.getElementById('chat-send');
        const playerTimerElement = document.getElementById('player-timer');
        const opponentTimerElement = document.getElementById('opponent-timer');
        const playerNameDisplay = document.getElementById('player-name');
        const opponentNameDisplay = document.getElementById('opponent-name');
        const playerImage = document.getElementById('player-image');
        const opponentImage = document.getElementById('opponent-image');
        const rewardAmountElement = document.getElementById('reward-amount');

        // ইভেন্ট লিসেনার
        chatButton.addEventListener('click', toggleChat);
        chatSendBtn.addEventListener('click', sendMessage);
        chatMessageInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') sendMessage();
        });

        // গেম শুরু
        if (gameId && playerId) {
            initializeGame();
        } else {
            statusElement.textContent = 'গেম আইডি বা প্লেয়ার আইডি পাওয়া যায়নি!';
        }

        function initializeGame() {
            gameRef = database.ref('games/' + gameId);
            chatRef = database.ref('chats/' + gameId);
            
            // Player 1 is white, Player 2 is black
            playerColor = (playerId === 1) ? 'white' : 'black';
            isBoardFlipped = (playerColor === 'black');

            // Fetch current user's data for their own display
            const currentUser = auth.currentUser;
            if (currentUser) {
                database.ref('users/' + currentUser.uid).once('value').then(snapshot => {
                    const userData = snapshot.val();
                    if (userData) {
                        playerName = userData.name || "আপনি";
                        playerPhotoUrl = userData.photoURL || '';
                        updatePlayerInfoDisplay();
                    }
                });
            }
            
            setupGameListeners();
            setupChatListeners();
            
            gameArea.style.display = 'block';
            rewardAmountElement.textContent = entryFee * 2; // Display potential reward
            updateTimerDisplay();
        }

        function updatePlayerInfoDisplay() {
            playerNameDisplay.textContent = playerName;
            if (playerPhotoUrl) {
                playerImage.innerHTML = `<img src="${playerPhotoUrl}" alt="Profile">`;
            } else {
                playerImage.innerHTML = `<i class="fas fa-user"></i>`;
            }
        }
        
        function updateOpponentInfoDisplay() {
            opponentNameDisplay.textContent = opponentName;
            if (opponentPhotoUrl) {
                opponentImage.innerHTML = `<img src="${opponentPhotoUrl}" alt="Opponent Profile">`;
            } else {
                opponentImage.innerHTML = `<i class="fas fa-user"></i>`;
            }
        }

        function setupGameListeners() {
            gameRef.on('value', (snapshot) => {
                const gameData = snapshot.val();
                
                if (!gameData) {
                    statusElement.textContent = 'গেম পাওয়া যায়নি বা শেষ হয়ে গেছে।';
                    // Disable game interactions if gameData is null
                    disableGameInteractions();
                    return;
                }

                if (gameData.status === 'finished') {
                    statusElement.textContent = 'গেম শেষ। ফলাফল প্রক্রিয়া করা হচ্ছে...';
                    disableGameInteractions();
                     setTimeout(() => {
                        if (window.opener && window.opener.location.href.includes("RealMoneyGame.html")) {
                             window.close(); // Close if opened by RealMoneyGame
                        } else {
                             window.location.href = 'RealMoneyGame.html'; // Fallback redirect
                        }
                    }, 5000);
                    return;
                }

                if (gameData.status === 'started' || gameData.status === 'waiting_for_players') { // 'waiting_for_players' might be initial status from RealMoneyGame
                    chessBoard = gameData.board || createInitialBoard();
                    currentPlayerTurn = gameData.currentPlayer; // 1 or 2
                    
                    if (playerId === 1) {
                        playerTimer = gameData.player1.timer;
                        opponentTimer = gameData.player2.timer;
                        opponentName = gameData.player2.name || "প্রতিপক্ষ";
                        opponentPhotoUrl = gameData.player2.photoURL || '';
                    } else {
                        playerTimer = gameData.player2.timer;
                        opponentTimer = gameData.player1.timer;
                        opponentName = gameData.player1.name || "প্রতিপক্ষ";
                        opponentPhotoUrl = gameData.player1.photoURL || '';
                    }
                    updateOpponentInfoDisplay();
                    
                    rewardAmountDisplay = gameData.entryFee * 2; // Assuming 2 players
                    rewardAmountElement.textContent = rewardAmountDisplay;
                    
                    lastMove = gameData.lastMove;
                    checkStatus = gameData.checkStatus || { white: false, black: false };
                    castlingRights = gameData.castlingRights || {
                        white: { kingSide: true, queenSide: true },
                        black: { kingSide: true, queenSide: true }
                    };
                    enPassantTarget = gameData.enPassantTarget;
                    halfMoveClock = gameData.halfMoveClock || 0;
                    fullMoveNumber = gameData.fullMoveNumber || 1;
                    gameInternalStatus = gameData.gameInternalStatus || 'ongoing';
                    
                    if (gameData.status === 'started' && !isGameStarted) {
                        isGameStarted = true;
                        if (currentPlayerTurn === playerId) { // If it's this player's turn by URL ID
                            startPlayerTimer();
                            stopOpponentTimer();
                        } else {
                            startOpponentTimer();
                            stopPlayerTimer();
                        }
                    }
                    
                    if (playerTimer <= 0 || opponentTimer <= 0) {
                        // Time ran out. Determine winner.
                        // If playerTimer <=0, current player (whose timer it is) loses.
                        // The one whose turn it *was* when timer ran out is the loser.
                        let timedOutPlayer;
                        if (playerTimer <= 0 && currentPlayerTurn === playerId) timedOutPlayer = playerId;
                        else if (opponentTimer <= 0 && currentPlayerTurn !== playerId) timedOutPlayer = (playerId === 1 ? 2 : 1);
                        
                        if(timedOutPlayer){
                            endGameByTimeout(timedOutPlayer);
                            return;
                        }
                    }
                    
                    renderBoard();
                    updateTimerDisplay();
                    updateStatus();
                }
            });
        }

        function disableGameInteractions() {
            isGameStarted = false; // Stop timers from running/updating Firebase
            clearInterval(playerTimerInterval);
            clearInterval(opponentTimerInterval);
            // Optionally, make board unclickable
            const boardElement = document.getElementById('board');
            if (boardElement) {
                boardElement.style.pointerEvents = 'none';
            }
        }


        function setupChatListeners() {
            chatRef.on('child_added', (snapshot) => {
                const message = snapshot.val();
                addMessageToChat(message.senderId, message.senderName, message.text, message.timestamp);
            });
        }

        function createInitialBoard() {
            // Standard chess starting position
            return [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'], // Black pieces (row 0)
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'], // Black pawns (row 1)
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'], // White pawns (row 6)
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']  // White pieces (row 7)
            ];
        }

        function renderBoard() {
            const boardElement = document.getElementById('board');
            boardElement.innerHTML = '';
            
            const rowsToRender = isBoardFlipped ? [0,1,2,3,4,5,6,7].reverse() : [0,1,2,3,4,5,6,7];
            const colsToRender = isBoardFlipped ? [0,1,2,3,4,5,6,7].reverse() : [0,1,2,3,4,5,6,7];
            
            for (let i_idx = 0; i_idx < 8; i_idx++) {
                const row = rowsToRender[i_idx];
                for (let j_idx = 0; j_idx < 8; j_idx++) {
                    const col = colsToRender[j_idx];
                    
                    const square = document.createElement('div');
                    square.className = `square ${(row + col) % 2 === 0 ? 'light' : 'dark'}`;
                    square.dataset.row = row;
                    square.dataset.col = col;
                    
                    if (lastMove && (
                        (lastMove.from.row === row && lastMove.from.col === col) ||
                        (lastMove.to.row === row && lastMove.to.col === col)
                    )) {
                        square.classList.add('last-move');
                    }
                    
                    const piece = chessBoard[row][col];
                    if (piece) {
                        const pieceColorName = (piece === piece.toUpperCase()) ? 'white' : 'black';
                        if (piece.toLowerCase() === 'k' && checkStatus[pieceColorName]) {
                            square.classList.add('check');
                        }
                        square.textContent = getPieceSymbol(piece);
                        square.classList.add(pieceColorName); // 'white' or 'black' class for styling piece color
                    }
                    
                    if (selectedPiece && selectedPiece.row === row && selectedPiece.col === col) {
                        square.classList.add('selected');
                    }
                    
                    const isPossible = possibleMoves.some(move => move.to.row === row && move.to.col === col);
                    if (isPossible) {
                        if (chessBoard[row][col]) { // Capture
                            square.classList.add('possible-capture');
                        } else { // Move to empty square
                            square.classList.add('possible-move');
                        }
                    }
                    
                    square.addEventListener('click', () => handleSquareClick(row, col));
                    boardElement.appendChild(square);
                }
            }
        }

        function getPieceSymbol(piece) {
            const symbols = {
                'r': '♜', 'n': '♞', 'b': '♝', 'q': '♛', 'k': '♚', 'p': '♟', // Black
                'R': '♖', 'N': '♘', 'B': '♗', 'Q': '♕', 'K': '♔', 'P': '♙'  // White
            };
            return symbols[piece] || '';
        }

        function handleSquareClick(row, col) {
            if (gameInternalStatus !== 'ongoing' || !isGameStarted || currentPlayerTurn !== playerId) return;
            
            const piece = chessBoard[row][col];
            
            if (selectedPiece) {
                if (selectedPiece.row === row && selectedPiece.col === col) {
                    selectedPiece = null;
                    possibleMoves = [];
                    renderBoard();
                    return;
                }
                
                const isPossible = possibleMoves.some(move => move.to.row === row && move.to.col === col);
                if (isPossible) {
                    const move = possibleMoves.find(m => m.to.row === row && m.to.col === col);
                    makeMove(move);
                    return;
                }
            }
            
            if (piece && isOwnPiece(piece)) {
                selectedPiece = { row, col, piece: piece };
                possibleMoves = getPossibleMoves(row, col, piece);
                renderBoard();
            } else { // Clicked on empty square or opponent's piece without a selected piece
                selectedPiece = null;
                possibleMoves = [];
                renderBoard();
            }
        }

        function isOwnPiece(piece) {
            const pieceColor = (piece === piece.toUpperCase()) ? 'white' : 'black';
            return pieceColor === playerColor;
        }


        function getPossibleMoves(row, col) {
            // This function should now correctly use playerColor
            const piece = chessBoard[row][col];
            const moves = [];
            if (!piece) return moves;

            // const colorOfPiece = (piece === piece.toUpperCase()) ? 'white' : 'black';
            // if (colorOfPiece !== playerColor) return moves; // Should not happen if isOwnPiece is checked before calling

            const pieceType = piece.toLowerCase();
            
            switch (pieceType) {
                case 'p': getPawnMoves(row, col, playerColor, moves); break;
                case 'r': getRookMoves(row, col, playerColor, moves); break;
                case 'n': getKnightMoves(row, col, playerColor, moves); break;
                case 'b': getBishopMoves(row, col, playerColor, moves); break;
                case 'q': 
                    getRookMoves(row, col, playerColor, moves);
                    getBishopMoves(row, col, playerColor, moves); 
                    break;
                case 'k': getKingMoves(row, col, playerColor, moves); break;
            }
            
            return moves.filter(move => {
                const tempBoard = JSON.parse(JSON.stringify(chessBoard));
                // const tempCastling = JSON.parse(JSON.stringify(castlingRights));
                // const tempEnPassant = enPassantTarget;
                
                executeMoveOnBoard(move, tempBoard); // Simplified execute for validation
                
                const kingPos = findKing(playerColor, tempBoard);
                if (!kingPos) return false; // Should not happen if king is on board
                
                const isInCheck = isSquareUnderAttack(
                    kingPos.row, kingPos.col, 
                    playerColor === 'white' ? 'black' : 'white', 
                    tempBoard
                );
                return !isInCheck;
            });
        }

        function executeMoveOnBoard(move, board) { // Simplified for validation
            const piece = board[move.from.row][move.from.col];
            board[move.to.row][move.to.col] = piece;
            board[move.from.row][move.from.col] = '';

            if (move.enPassant) {
                const capturedPawnRow = playerColor === 'white' ? move.to.row + 1 : move.to.row - 1;
                board[capturedPawnRow][move.to.col] = '';
            }
            // Simplified: does not handle castling or promotion for this temp check
        }


        function getPawnMoves(r, c, color, moves) {
            const dir = color === 'white' ? -1 : 1;
            const startRow = color === 'white' ? 6 : 1;
            const endRow = color === 'white' ? 0 : 7;

            // Forward 1
            if (isValidSquare(r + dir, c) && chessBoard[r + dir][c] === '') {
                moves.push(createMove(r, c, r + dir, c));
                // Forward 2 from start
                if (r === startRow && chessBoard[r + 2 * dir][c] === '') {
                    moves.push(createMove(r, c, r + 2 * dir, c));
                }
            }
            // Capture
            for (let dc of [-1, 1]) {
                if (isValidSquare(r + dir, c + dc)) {
                    const targetPiece = chessBoard[r + dir][c + dc];
                    if (targetPiece && isEnemyPiece(targetPiece, color)) {
                        moves.push(createMove(r, c, r + dir, c + dc));
                    }
                    // En Passant
                    if (enPassantTarget && enPassantTarget.row === r + dir && enPassantTarget.col === c + dc) {
                         moves.push({ from: {row: r, col: c}, to: {row: r + dir, col: c + dc}, enPassant: true });
                    }
                }
            }
        }

        function getRookMoves(r, c, color, moves) {
            const directions = [[-1,0], [1,0], [0,-1], [0,1]];
            getSlidingMoves(r, c, color, directions, moves);
        }

        function getKnightMoves(r, c, color, moves) {
            const knightDeltas = [[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for (const [dr, dc] of knightDeltas) {
                const nr = r + dr;
                const nc = c + dc;
                if (isValidSquare(nr, nc) && (chessBoard[nr][nc] === '' || isEnemyPiece(chessBoard[nr][nc], color))) {
                    moves.push(createMove(r, c, nr, nc));
                }
            }
        }

        function getBishopMoves(r, c, color, moves) {
            const directions = [[-1,-1],[-1,1],[1,-1],[1,1]];
            getSlidingMoves(r, c, color, directions, moves);
        }

        function getKingMoves(r, c, color, moves) {
            for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const nr = r + dr;
                    const nc = c + dc;
                    if (isValidSquare(nr, nc) && (chessBoard[nr][nc] === '' || isEnemyPiece(chessBoard[nr][nc], color))) {
                        moves.push(createMove(r, c, nr, nc));
                    }
                }
            }
            getCastlingMoves(r, c, color, moves);
        }
        
        function getCastlingMoves(r, c, color, moves) {
            if (isSquareUnderAttack(r, c, color === 'white' ? 'black' : 'white', chessBoard)) return;

            const rights = castlingRights[color];
            // King-side
            if (rights.kingSide && chessBoard[r][c+1] === '' && chessBoard[r][c+2] === '' &&
                !isSquareUnderAttack(r, c+1, color === 'white' ? 'black' : 'white', chessBoard) &&
                !isSquareUnderAttack(r, c+2, color === 'white' ? 'black' : 'white', chessBoard)) {
                moves.push({ from: {row:r, col:c}, to: {row:r, col:c+2}, castling: 'kingSide' });
            }
            // Queen-side
            if (rights.queenSide && chessBoard[r][c-1] === '' && chessBoard[r][c-2] === '' && chessBoard[r][c-3] === '' &&
                !isSquareUnderAttack(r, c-1, color === 'white' ? 'black' : 'white', chessBoard) &&
                !isSquareUnderAttack(r, c-2, color === 'white' ? 'black' : 'white', chessBoard)) {
                 moves.push({ from: {row:r, col:c}, to: {row:r, col:c-2}, castling: 'queenSide' });
            }
        }


        function getSlidingMoves(r, c, color, directions, moves) {
            for (const [dr, dc] of directions) {
                let nr = r + dr;
                let nc = c + dc;
                while (isValidSquare(nr, nc)) {
                    if (chessBoard[nr][nc] === '') {
                        moves.push(createMove(r, c, nr, nc));
                    } else {
                        if (isEnemyPiece(chessBoard[nr][nc], color)) {
                            moves.push(createMove(r, c, nr, nc));
                        }
                        break; 
                    }
                    nr += dr;
                    nc += dc;
                }
            }
        }

        function createMove(fromRow, fromCol, toRow, toCol) {
            return { from: { row: fromRow, col: fromCol }, to: { row: toRow, col: toCol } };
        }

        function isValidSquare(row, col) {
            return row >= 0 && row < 8 && col >= 0 && col < 8;
        }

        function isEnemyPiece(pieceToCheck, ownColor) {
            if (!pieceToCheck) return false;
            const pieceToCheckColor = (pieceToCheck === pieceToCheck.toUpperCase()) ? 'white' : 'black';
            return pieceToCheckColor !== ownColor;
        }


        function makeMove(move) {
            const pieceToMove = chessBoard[move.from.row][move.from.col];
            
            // Actual board update
            chessBoard[move.from.row][move.from.col] = '';
            chessBoard[move.to.row][move.to.col] = pieceToMove;

            let promotionPiece = null;

            // Handle special moves for board state
            if (move.enPassant) {
                const capturedPawnRow = playerColor === 'white' ? move.to.row + 1 : move.to.row - 1;
                chessBoard[capturedPawnRow][move.to.col] = ''; 
            } else if (move.castling) {
                if (move.castling === 'kingSide') {
                    chessBoard[move.to.row][move.to.col - 1] = chessBoard[move.to.row][7];
                    chessBoard[move.to.row][7] = '';
                } else { // queenSide
                    chessBoard[move.to.row][move.to.col + 1] = chessBoard[move.to.row][0];
                    chessBoard[move.to.row][0] = '';
                }
            } else if (pieceToMove.toLowerCase() === 'p' && (move.to.row === 0 || move.to.row === 7)) {
                // Pawn promotion - show modal and defer rest of makeMove logic
                showPromotionModal(move.to.row, move.to.col, playerColor, move);
                return; // Halt further processing until promotion is chosen
            }

            // If not promotion, or promotion handled elsewhere, proceed with common logic
            finalizeMove(move, pieceToMove, promotionPiece);
        }

        function finalizeMove(move, originalPiece, promotedToPiece) {
            const pieceMoved = promotedToPiece || originalPiece;

            // En Passant Target
            enPassantTarget = null;
            if (originalPiece.toLowerCase() === 'p' && Math.abs(move.from.row - move.to.row) === 2) {
                enPassantTarget = { row: (move.from.row + move.to.row) / 2, col: move.from.col };
            }

            // Update Castling Rights
            updateCastlingRights(move.from, originalPiece);
            if (move.to.row === (playerColor === 'white' ? 0 : 7) && chessBoard[move.to.row][move.to.col].toLowerCase() === 'r') { // if rook captured on its starting square
                if (move.to.col === 0) castlingRights[playerColor === 'white' ? 'black' : 'white'].queenSide = false;
                if (move.to.col === 7) castlingRights[playerColor === 'white' ? 'black' : 'white'].kingSide = false;
            }


            // Halfmove clock
            if (originalPiece.toLowerCase() === 'p' || chessBoard[move.to.row][move.to.col]) { // pawn move or capture
                halfMoveClock = 0;
            } else {
                halfMoveClock++;
            }

            // Fullmove number
            if (playerColor === 'black') { // Current player is black
                fullMoveNumber++;
            }
            
            lastMove = { from: move.from, to: move.to };
            
            const nextPlayerTurn = (currentPlayerTurn === 1) ? 2 : 1;
            
            // Stop own timer, Firebase listener will start opponent's effectively
            stopPlayerTimer(); 
            // The listener should handle starting the correct timer based on currentPlayerTurn from Firebase
            
            updateCheckStatus();
            checkGameEndCondition(); // This will set gameInternalStatus if game ends

            let firebaseUpdates = {
                board: chessBoard,
                currentPlayer: nextPlayerTurn,
                lastMove: lastMove,
                checkStatus: checkStatus,
                castlingRights: castlingRights,
                enPassantTarget: enPassantTarget,
                halfMoveClock: halfMoveClock,
                fullMoveNumber: fullMoveNumber,
                gameInternalStatus: gameInternalStatus, // e.g., 'ongoing', 'whiteWon'
                lastMoveTime: firebase.database.ServerValue.TIMESTAMP
            };

            // Update player timers in Firebase
            if (playerId === 1) { // Current client is player 1
                firebaseUpdates['player1/timer'] = playerTimer;
            } else { // Current client is player 2
                firebaseUpdates['player2/timer'] = playerTimer;
            }
            
            gameRef.update(firebaseUpdates);

            selectedPiece = null;
            possibleMoves = [];
            // renderBoard(); // Will be re-rendered by listener
            // updateStatus(); // Will be re-rendered by listener

            if (gameInternalStatus !== 'ongoing') {
                 handleGameEnd();
            }
        }


        function showPromotionModal(row, col, color, originalMove) {
            const modal = document.getElementById('promotion-modal');
            const optionsContainer = document.getElementById('promotion-options');
            optionsContainer.innerHTML = ''; // Clear previous options

            const piecesToPromoteTo = ['Q', 'R', 'B', 'N'];
            piecesToPromoteTo.forEach(p => {
                const optionDiv = document.createElement('div');
                optionDiv.className = `promotion-option ${color}`;
                optionDiv.dataset.piece = p;
                optionDiv.textContent = getPieceSymbol(color === 'white' ? p : p.toLowerCase());
                optionDiv.onclick = () => {
                    const promotedPiece = color === 'white' ? p : p.toLowerCase();
                    chessBoard[row][col] = promotedPiece; // Finalize promotion on board
                    modal.style.display = 'none';
                    finalizeMove(originalMove, chessBoard[row][col] /* this is now the pawn */, promotedPiece);
                };
                optionsContainer.appendChild(optionDiv);
            });
            modal.style.display = 'block';
        }

        function updateCastlingRights(from, piece) {
            const pieceType = piece.toLowerCase();
            const pieceColor = (piece === piece.toUpperCase()) ? 'white' : 'black';

            if (pieceType === 'k') {
                castlingRights[pieceColor].kingSide = false;
                castlingRights[pieceColor].queenSide = false;
            } else if (pieceType === 'r') {
                if (from.row === (pieceColor === 'white' ? 7 : 0)) {
                    if (from.col === 0) castlingRights[pieceColor].queenSide = false;
                    if (from.col === 7) castlingRights[pieceColor].kingSide = false;
                }
            }
        }
        
        function updateCheckStatus() {
            const whiteKingPos = findKing('white', chessBoard);
            const blackKingPos = findKing('black', chessBoard);
            
            if(whiteKingPos) {
                checkStatus.white = isSquareUnderAttack(whiteKingPos.row, whiteKingPos.col, 'black', chessBoard);
            }
            if(blackKingPos) {
                checkStatus.black = isSquareUnderAttack(blackKingPos.row, blackKingPos.col, 'white', chessBoard);
            }
        }

        function findKing(color, boardToSearch) {
            const kingPiece = color === 'white' ? 'K' : 'k';
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    if (boardToSearch[r][c] === kingPiece) return { row: r, col: c };
                }
            }
            return null; 
        }

        function isSquareUnderAttack(r, c, attackerColor, boardToSearch) {
            for (let R = 0; R < 8; R++) {
                for (let C = 0; C < 8; C++) {
                    const piece = boardToSearch[R][C];
                    if (piece) {
                        const pieceColor = (piece === piece.toUpperCase()) ? 'white' : 'black';
                        if (pieceColor === attackerColor) {
                            const rawMoves = []; // Get raw moves without check validation for this piece
                            const pieceType = piece.toLowerCase();
                            // Simplified raw move generation (doesn't need to be perfect, just find if target is attacked)
                            if (pieceType === 'p') {
                                const dir = attackerColor === 'white' ? -1 : 1;
                                if (isValidSquare(R + dir, C - 1)) rawMoves.push(createMove(R,C,R+dir,C-1));
                                if (isValidSquare(R + dir, C + 1)) rawMoves.push(createMove(R,C,R+dir,C+1));
                            } else if (pieceType === 'r') getRookMoves(R, C, attackerColor, rawMoves);
                            else if (pieceType === 'n') getKnightMoves(R, C, attackerColor, rawMoves);
                            else if (pieceType === 'b') getBishopMoves(R, C, attackerColor, rawMoves);
                            else if (pieceType === 'q') { getRookMoves(R, C, attackerColor, rawMoves); getBishopMoves(R, C, attackerColor, rawMoves); }
                            else if (pieceType === 'k') {
                                for (let dr = -1; dr <= 1; dr++) for (let dc = -1; dc <= 1; dc++) {
                                    if (dr===0 && dc===0) continue;
                                    if (isValidSquare(R+dr, C+dc)) rawMoves.push(createMove(R,C,R+dr,C+dc));
                                }
                            }

                            if (rawMoves.some(m => m.to.row === r && m.to.col === c)) return true;
                        }
                    }
                }
            }
            return false;
        }
        
        function checkGameEndCondition() {
            const turnColor = (currentPlayerTurn === 1) ? 'white' : 'black'; // Color whose turn it WILL BE
            const opponentColor = (turnColor === 'white') ? 'black' : 'white';

            let hasAnyLegalMoves = false;
            for (let r = 0; r < 8; r++) {
                for (let c = 0; c < 8; c++) {
                    const piece = chessBoard[r][c];
                    if (piece) {
                        const pieceC = (piece === piece.toUpperCase()) ? 'white' : 'black';
                        if (pieceC === turnColor) { // Check moves for the player whose turn it is next
                            if (getPossibleMoves(r, c).length > 0) {
                                hasAnyLegalMoves = true;
                                break;
                            }
                        }
                    }
                }
                if (hasAnyLegalMoves) break;
            }

            const kingInCheck = checkStatus[turnColor];

            if (!hasAnyLegalMoves) {
                if (kingInCheck) { // Checkmate
                    gameInternalStatus = (turnColor === 'white') ? 'blackWon' : 'whiteWon';
                } else { // Stalemate
                    gameInternalStatus = 'stalemate';
                }
            } else if (halfMoveClock >= 100) { // 50 moves by each player
                gameInternalStatus = 'draw'; // 50-move rule
            } else if (isInsufficientMaterial()) {
                gameInternalStatus = 'draw';
            }
        }


        function isInsufficientMaterial() {
            // Simplified check for now. True for K vs K, K vs KB, K vs KN
            // A more comprehensive check would involve counting pieces.
            const pieces = chessBoard.flat().filter(p => p !== '');
            if (pieces.length <= 2) return true; // K vs K
            if (pieces.length === 3) {
                const pieceTypes = pieces.map(p => p.toLowerCase()).sort().join('');
                if (pieceTypes === 'bkk' || pieceTypes === 'kkn') return true; // K vs KB or K vs KN
            }
            return false;
        }

        function handleGameEnd() {
            disableGameInteractions();
            let resultForFirebase;
            let winningPlayerNumber = 0; // 0 for draw

            if (gameInternalStatus === 'whiteWon') {
                resultForFirebase = 'player1_won'; // P1 is white
                winningPlayerNumber = 1;
            } else if (gameInternalStatus === 'blackWon') {
                resultForFirebase = 'player2_won'; // P2 is black
                winningPlayerNumber = 2;
            } else { // stalemate or draw
                resultForFirebase = 'draw';
            }
            updateStatus(); // Show final status like "White Won!"

            gameRef.update({
                status: 'finished',
                result: resultForFirebase,
                winnerId: winningPlayerNumber, // Store the player number (1 or 2) or 0 for draw
                endTime: firebase.database.ServerValue.TIMESTAMP
            });
            // RealMoneyGame.html will listen for status: 'finished' and handle rewards.
        }
        
        function endGameByTimeout(timedOutPlayerNumber) {
            if (gameInternalStatus !== 'ongoing') return; // Game already ended

            disableGameInteractions();
            const winnerPlayerNumber = (timedOutPlayerNumber === 1) ? 2 : 1;
            gameInternalStatus = (winnerPlayerNumber === 1) ? 'whiteWon' : 'blackWon'; // Assuming P1=White, P2=Black
            
            statusElement.textContent = `প্লেয়ার ${timedOutPlayerNumber} টাইম আউট! প্লেয়ার ${winnerPlayerNumber} জয়ী!`;
            statusElement.style.color = '#4CAF50'; // Or appropriate color

            gameRef.update({
                status: 'finished',
                result: (winnerPlayerNumber === 1 ? 'player1_won' : 'player2_won'),
                winnerId: winnerPlayerNumber,
                reason: 'timeout',
                timedOutPlayer: timedOutPlayerNumber,
                endTime: firebase.database.ServerValue.TIMESTAMP
            });
        }

        function startPlayerTimer() {
            clearInterval(playerTimerInterval);
            playerTimerInterval = setInterval(() => {
                if (!isGameStarted || currentPlayerTurn !== playerId || gameInternalStatus !== 'ongoing') {
                    clearInterval(playerTimerInterval);
                    return;
                }
                playerTimer--;
                updateTimerDisplay();
                if (playerTimer <= 0) {
                    endGameByTimeout(playerId);
                } else if (playerTimer % 5 === 0) { // Update Firebase every 5 seconds
                     gameRef.update({ [`player${playerId}/timer`]: playerTimer });
                }
            }, 1000);
        }
        function stopPlayerTimer() {
            clearInterval(playerTimerInterval);
        }

        function startOpponentTimer() {
            clearInterval(opponentTimerInterval);
            opponentTimerInterval = setInterval(() => {
                 if (!isGameStarted || currentPlayerTurn === playerId || gameInternalStatus !== 'ongoing') {
                    clearInterval(opponentTimerInterval);
                    return;
                }
                opponentTimer--; // This is just for local display, actual time comes from Firebase
                updateTimerDisplay();
                if (opponentTimer <= 0) {
                   // This should be handled by the opponent's client, or server logic
                   // Or if their timer from Firebase shows 0, this client can declare win.
                   // endGameByTimeout(playerId === 1 ? 2 : 1); // Declare win if opponent's timer is 0
                }
            }, 1000);
        }
        function stopOpponentTimer() {
            clearInterval(opponentTimerInterval);
        }


        function updateTimerDisplay() {
            const format = (s) => `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`;
            playerTimerElement.textContent = format(playerTimer);
            opponentTimerElement.textContent = format(opponentTimer);
        }

        function updateStatus() {
            let msg = "";
            const currentTurnColor = (currentPlayerTurn === 1) ? 'white' : 'black';

            if (gameInternalStatus === 'ongoing') {
                msg = (currentPlayerTurn === playerId) ? "আপনার পালা" : "প্রতিপক্ষের পালা";
                if (checkStatus[currentTurnColor]) {
                    msg += " (চেক!)";
                }
            } else if (gameInternalStatus === 'whiteWon') {
                msg = "সাদা জয়ী!";
            } else if (gameInternalStatus === 'blackWon') {
                msg = "কালো জয়ী!";
            } else if (gameInternalStatus === 'stalemate') {
                msg = "স্টেলমেট - ড্র!";
            } else if (gameInternalStatus === 'draw') {
                msg = "ড্র!";
            }
            statusElement.textContent = msg;
        }


        function toggleChat() {
            chatContainer.style.display = chatContainer.style.display === 'flex' ? 'none' : 'flex';
            if (chatContainer.style.display === 'flex') {
                chatMessageInput.focus();
                chatMessages.scrollTop = chatMessages.scrollHeight;
            }
        }

        function sendMessage() {
            const messageText = chatMessageInput.value.trim();
            if (!messageText || !chatRef || !gameId) return;
            
            const currentUser = auth.currentUser;
            if (!currentUser) return;

            chatRef.push({
                senderId: currentUser.uid, // Use Firebase UID for sender ID
                senderName: playerName, // Use the current player's name
                text: messageText,
                timestamp: firebase.database.ServerValue.TIMESTAMP
            });
            chatMessageInput.value = '';
        }

        function addMessageToChat(senderId, senderNameText, text, timestamp) {
            const messageDiv = document.createElement('div');
            const isOwn = auth.currentUser && senderId === auth.currentUser.uid;
            
            messageDiv.className = `message ${isOwn ? 'own-message' : 'opponent-message'}`;
            
            const time = timestamp ? new Date(timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'}) : '';
            
            messageDiv.textContent = `${senderNameText || (isOwn ? 'আপনি' : 'প্রতিপক্ষ')}: ${text} (${time})`;
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        function exitGame() {
            if (confirm('আপনি কি নিশ্চিত গেম থেকে বের হতে চান? আপনি হেরে যাবেন।')) {
                if (gameInternalStatus === 'ongoing' && gameRef) {
                    const losingPlayer = playerId; // The player exiting
                    const winningPlayer = (playerId === 1) ? 2 : 1;
                    
                    gameRef.update({
                        status: 'finished',
                        result: (winningPlayer === 1 ? 'player1_won' : 'player2_won'),
                        winnerId: winningPlayer,
                        reason: 'abandoned',
                        abandoningPlayer: losingPlayer,
                        endTime: firebase.database.ServerValue.TIMESTAMP
                    }).then(() => {
                        window.location.href = 'RealMoneyGame.html'; // Or close tab if opened by RealMoneyGame
                    });
                } else {
                     window.location.href = 'RealMoneyGame.html';
                }
            }
        }
    </script>
</body>
</html>
